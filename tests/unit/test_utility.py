# Generated By: Cursor (Claude Sonnet 4.5)
"""
Unit tests for utility.py metric manipulation functions

These tests verify the Prometheus metric creation and manipulation functions.
"""

import sys
import unittest
from pathlib import Path

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))


class TestMetricCreation(unittest.TestCase):
    """Test metric creation functions"""

    def setUp(self):
        """Clear prometheus registry before each test"""
        import prometheus_client

        prometheus_client.REGISTRY._collector_to_names.clear()
        prometheus_client.REGISTRY._names_to_collectors.clear()

        import utility

        utility.gauges = {}
        utility.counters = {}

    def test_set_creates_gauge_metric(self):
        """Test that set() creates a new gauge metric"""
        import utility

        utility.set("test_gauge", 42, {"device": "test"})

        # Verify gauge was created
        self.assertIn("test_gauge", utility.gauges)

    def test_set_updates_existing_gauge(self):
        """Test that set() updates an existing gauge metric"""
        import utility

        utility.set("test_gauge", 100, {"device": "test"})
        utility.set("test_gauge", 200, {"device": "test"})

        # Gauge should still exist and be updated
        self.assertIn("test_gauge", utility.gauges)

    def test_inc_creates_counter_metric(self):
        """Test that inc() creates a new counter metric"""
        import utility

        utility.inc("test_counter", {"device": "test"})

        # Verify counter was created
        self.assertIn("test_counter", utility.counters)

    def test_inc_increments_existing_counter(self):
        """Test that inc() increments an existing counter"""
        import utility

        # Increment twice
        utility.inc("test_counter", {"device": "test"})
        utility.inc("test_counter", {"device": "test"})

        # Counter should exist (we can't easily check the value without
        # accessing Prometheus internals, but we verify it doesn't crash)
        self.assertIn("test_counter", utility.counters)


class TestMetricTracking(unittest.TestCase):
    """Test that metrics are tracked in gauges/counters dicts"""

    def setUp(self):
        """Clear prometheus registry before each test"""
        import prometheus_client

        prometheus_client.REGISTRY._collector_to_names.clear()
        prometheus_client.REGISTRY._names_to_collectors.clear()

        import utility

        utility.gauges = {}
        utility.counters = {}

    def test_gauge_tracked_after_creation(self):
        """Test that gauge is tracked in gauges dict"""
        import utility

        utility.set("test_gauge", 100, {"device": "test"})

        self.assertIn("test_gauge", utility.gauges)

    def test_counter_tracked_after_creation(self):
        """Test that counter is tracked in counters dict"""
        import utility

        utility.inc("test_counter", {"device": "test"})

        self.assertIn("test_counter", utility.counters)


class TestMetricDeletion(unittest.TestCase):
    """Test metric deletion with None value"""

    def setUp(self):
        """Clear prometheus registry before each test"""
        import prometheus_client

        prometheus_client.REGISTRY._collector_to_names.clear()
        prometheus_client.REGISTRY._names_to_collectors.clear()

        import utility

        utility.gauges = {}
        utility.counters = {}

    def test_delete_removes_label_combination(self):
        """Test that setting gauge to None removes that label combination"""
        import utility

        # Create gauge
        utility.set("test_gauge", 100, {"device": "test"})
        self.assertIn("test_gauge", utility.gauges)

        # Delete gauge label combination with None value (calls gauge.remove())
        utility.set("test_gauge", None, {"device": "test"})

        # Gauge object still exists in tracking dict (can't easily verify removal without Prometheus internals)
        # Just verify the call doesn't crash
        self.assertIn("test_gauge", utility.gauges)

    def test_delete_nonexistent_metric_doesnt_crash(self):
        """Test that deleting a nonexistent metric doesn't crash"""
        import utility

        # Should not raise exception
        utility.set("nonexistent", None, {"device": "test"})


class TestMetricLabels(unittest.TestCase):
    """Test that metrics correctly handle labels"""

    def setUp(self):
        """Clear prometheus registry before each test"""
        import prometheus_client

        prometheus_client.REGISTRY._collector_to_names.clear()
        prometheus_client.REGISTRY._names_to_collectors.clear()

        import utility

        utility.gauges = {}
        utility.counters = {}

    def test_metrics_with_different_labels_are_independent(self):
        """Test that same metric name with different labels creates separate timeseries"""
        import utility

        # Create same metric with different labels
        utility.set("temperature", 20.0, {"device": "sensor1"})
        utility.set("temperature", 25.0, {"device": "sensor2"})

        # Both should exist
        self.assertIn("temperature", utility.gauges)

    def test_counter_with_multiple_labels(self):
        """Test counters with multiple label dimensions"""
        import utility

        labels = {"device_type": "telescope", "device_number": "0", "attribute": "altitude"}

        utility.inc("alpaca_success_total", labels)
        utility.inc("alpaca_success_total", labels)

        self.assertIn("alpaca_success_total", utility.counters)

    def test_gauge_with_empty_labels(self):
        """Test that gauges work with empty label dict"""
        import utility

        utility.set("simple_metric", 100, {})

        self.assertIn("simple_metric", utility.gauges)


class TestMetricValueTypes(unittest.TestCase):
    """Test different metric value types"""

    def setUp(self):
        """Clear prometheus registry before each test"""
        import prometheus_client

        prometheus_client.REGISTRY._collector_to_names.clear()
        prometheus_client.REGISTRY._names_to_collectors.clear()

        import utility

        utility.gauges = {}
        utility.counters = {}

    def test_set_with_integer_value(self):
        """Test setting gauge with integer value"""
        import utility

        utility.set("int_gauge", 42, {"device": "test"})
        self.assertIn("int_gauge", utility.gauges)

    def test_set_with_float_value(self):
        """Test setting gauge with float value"""
        import utility

        utility.set("float_gauge", 3.14159, {"device": "test"})
        self.assertIn("float_gauge", utility.gauges)

    def test_set_with_zero_value(self):
        """Test setting gauge with zero value"""
        import utility

        utility.set("zero_gauge", 0, {"device": "test"})
        self.assertIn("zero_gauge", utility.gauges)

    def test_set_with_negative_value(self):
        """Test setting gauge with negative value"""
        import utility

        utility.set("negative_gauge", -10.5, {"device": "test"})
        self.assertIn("negative_gauge", utility.gauges)


if __name__ == "__main__":
    unittest.main()
