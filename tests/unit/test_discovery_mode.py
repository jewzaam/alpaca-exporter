# Generated By: Cursor (Claude Sonnet 4.5)
"""
Unit tests for auto-discovery mode behavior

These tests verify behavior specific to the --discover flag (permissive mode).
In this mode, devices that never connect are silently ignored.
"""

import json
import sys
import unittest
from pathlib import Path
from unittest.mock import Mock, patch

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))


class TestDiscoveryMode(unittest.TestCase):
    """Test auto-discovery mode specific behavior"""

    @patch("requests.get")
    def test_discovery_filters_by_device_type(self, mock_get):
        """
        Test that discovery only includes supported device types.

        The Management API might return device types we don't support.
        These should be filtered out and logged as SKIPPED.
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API response with mix of supported and unsupported devices
        mock_response = Mock()
        mock_response.status_code = 200
        devices_data = {
            "Value": [
                # Supported device types
                {"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "SimTelescope", "UniqueID": "tel-001"},
                {"DeviceType": "Camera", "DeviceNumber": 0, "DeviceName": "SimCamera", "UniqueID": "cam-001"},
                # Unsupported device type (should be filtered out)
                {"DeviceType": "UnsupportedType", "DeviceNumber": 0, "DeviceName": "Unknown", "UniqueID": "unk-001"},
            ],
            "ErrorNumber": 0,
            "ErrorMessage": "",
        }
        mock_response.text = json.dumps(devices_data)
        mock_get.return_value = mock_response

        # Call discovery (verbose=False to avoid log output)
        discovered = alpaca_exporter.discoverDevices(
            alpaca_base_url="http://localhost:11111/api/v1",
            verbose=False,
        )

        # Should only include supported device types
        self.assertIn("telescope", discovered, "Supported telescope should be discovered")
        self.assertIn("camera", discovered, "Supported camera should be discovered")
        self.assertNotIn("unsupportedtype", discovered, "Unsupported device type should be filtered out")

    @patch("requests.get")
    def test_discovery_handles_multiple_devices_same_type(self, mock_get):
        """
        Test discovery with multiple devices of the same type.

        Should organize devices by type with device numbers in a list:
        {device_type: [device_number1, device_number2, ...]}
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API with multiple cameras
        mock_response = Mock()
        mock_response.status_code = 200
        devices_data = {
            "Value": [
                {"DeviceType": "Camera", "DeviceNumber": 0, "DeviceName": "MainCamera", "UniqueID": "cam-001"},
                {"DeviceType": "Camera", "DeviceNumber": 1, "DeviceName": "GuideCamera", "UniqueID": "cam-002"},
                {"DeviceType": "Camera", "DeviceNumber": 2, "DeviceName": "AllSkyCamera", "UniqueID": "cam-003"},
            ],
            "ErrorNumber": 0,
            "ErrorMessage": "",
        }
        mock_response.text = json.dumps(devices_data)
        mock_get.return_value = mock_response

        discovered = alpaca_exporter.discoverDevices(
            alpaca_base_url="http://localhost:11111/api/v1",
            verbose=False,
        )

        # Verify all three cameras were discovered
        self.assertIn("camera", discovered, "Camera device type should be present")
        self.assertEqual(len(discovered["camera"]), 3, "Should discover all 3 cameras")
        self.assertIn(0, discovered["camera"], "Camera #0 should be discovered")
        self.assertIn(1, discovered["camera"], "Camera #1 should be discovered")
        self.assertIn(2, discovered["camera"], "Camera #2 should be discovered")

    @patch("requests.get")
    def test_discovery_handles_failed_management_api(self, mock_get):
        """
        Test discovery behavior when Management API returns an error.

        Should return empty dict and handle gracefully (not crash).
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API returning HTTP error
        mock_response = Mock()
        mock_response.status_code = 500
        mock_response.text = "Internal Server Error"
        mock_get.return_value = mock_response

        # Should handle error gracefully
        discovered = alpaca_exporter.discoverDevices(
            alpaca_base_url="http://localhost:11111/api/v1",
            verbose=False,
        )

        # Should return empty dict when API fails
        self.assertEqual(len(discovered), 0, "Failed API call should return empty dict")
        self.assertIsInstance(discovered, dict, "Should still return a dict even on error")

    @patch("requests.get")
    def test_discovery_handles_missing_value_field(self, mock_get):
        """
        Test discovery when Management API response is missing the Value field.

        Malformed responses should be handled gracefully.
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API with malformed response (missing Value field)
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.text = json.dumps({"ErrorNumber": 0, "ErrorMessage": ""})
        mock_get.return_value = mock_response

        discovered = alpaca_exporter.discoverDevices(
            alpaca_base_url="http://localhost:11111/api/v1",
            verbose=False,
        )

        # Should return empty dict for malformed response
        self.assertEqual(len(discovered), 0, "Malformed response should return empty dict")


class TestDiscoveryVerboseFlag(unittest.TestCase):
    """Test verbose flag behavior in discovery"""

    @patch("requests.get")
    @patch("builtins.print")
    def test_verbose_true_prints_discovered_devices(self, mock_print, mock_get):
        """
        Test that verbose=True prints DISCOVERED messages.

        When verbose=True, discovery should print info about each device found.
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API response
        mock_response = Mock()
        mock_response.status_code = 200
        devices_data = {
            "Value": [
                {"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "SimTelescope", "UniqueID": "tel-001"},
            ],
            "ErrorNumber": 0,
            "ErrorMessage": "",
        }
        mock_response.text = json.dumps(devices_data)
        mock_get.return_value = mock_response

        # Call with verbose=True
        discovered = alpaca_exporter.discoverDevices(
            alpaca_base_url="http://localhost:11111/api/v1",
            verbose=True,
        )

        # Verify print was called with discovery message
        # Should print something like "DISCOVERED: telescope/0 - SimTelescope"
        print_calls = [str(call) for call in mock_print.call_args_list]
        discovered_message_found = any("DISCOVERED" in str(call) and "telescope/0" in str(call) for call in print_calls)
        self.assertTrue(discovered_message_found, "verbose=True should print DISCOVERED message for devices")

    @patch("requests.get")
    @patch("builtins.print")
    def test_verbose_false_no_discovery_output(self, mock_print, mock_get):
        """
        Test that verbose=False suppresses DISCOVERED messages.

        When verbose=False (typical for runtime polling), should not print
        discovery messages (they would spam logs every cycle).
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API response
        mock_response = Mock()
        mock_response.status_code = 200
        devices_data = {
            "Value": [
                {"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "SimTelescope", "UniqueID": "tel-001"},
            ],
            "ErrorNumber": 0,
            "ErrorMessage": "",
        }
        mock_response.text = json.dumps(devices_data)
        mock_get.return_value = mock_response

        # Reset print mock
        mock_print.reset_mock()

        # Call with verbose=False
        discovered = alpaca_exporter.discoverDevices(
            alpaca_base_url="http://localhost:11111/api/v1",
            verbose=False,
        )

        # Verify print was NOT called with DISCOVERED message
        # (It might be called for errors/warnings, but not for normal discovery)
        print_calls = [str(call) for call in mock_print.call_args_list]
        discovered_message_found = any("DISCOVERED" in str(call) and "telescope" in str(call) for call in print_calls)
        self.assertFalse(discovered_message_found, "verbose=False should NOT print DISCOVERED messages")


if __name__ == "__main__":
    unittest.main()
