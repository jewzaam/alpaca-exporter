# Generated By: Cursor (Claude Sonnet 4.5)
"""
Unit tests for Alpaca server availability scenarios

Tests verify correct behavior when Alpaca server becomes unavailable:
- During startup (retry indefinitely)
- During runtime (mark devices disconnected, keep running)
"""

import json
import sys
import unittest
from pathlib import Path
from unittest.mock import Mock, patch

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))


class TestServerUnavailableAtStartup(unittest.TestCase):
    """Test exporter behavior when Alpaca server unavailable at startup"""

    @patch("requests.get")
    def test_startup_retries_when_server_unavailable(self, mock_get):
        """
        Test that exporter retries indefinitely when server unavailable at startup.

        Expected behavior:
        - Should NOT exit (no os._exit(-1))
        - Should retry in loop with sleep
        - No metrics created until server available
        - Eventually succeeds when server comes online

        From requirements:
        "Startup: Retry in loop indefinitely, do not create metrics, wait for server"

        This test will FAIL with current code because:
        - Lines 235-237: Calls os._exit(-1) instead of retrying
        - Line 228: Sets done=True immediately in manual mode
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Simulate server completely unavailable (connection refused)
        mock_get.side_effect = Exception("Connection refused")

        # Try discovery
        discovered = alpaca_exporter.discoverDevices(alpaca_base_url="http://localhost:11111/api/v1", verbose=False)

        # When server unavailable, should return empty dict and retry
        # Should NOT crash or exit
        self.assertEqual(len(discovered), 0, "Should return empty dict when server unavailable")

        # The main startup loop (lines 209-237) should:
        # 1. Call discoverDevices()
        # 2. Get empty result
        # 3. Print warning
        # 4. Sleep and retry
        # 5. NOT call os._exit(-1)

    @patch("requests.get")
    def test_startup_no_metrics_until_server_available(self, mock_get):
        """
        Test that no metrics are created until server becomes available.

        Expected:
        - Startup retry loop doesn't create any metrics
        - utility.metrics() not called until after successful connection
        - No gauges or counters created during retry phase
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Server unavailable
        mock_get.side_effect = Exception("Connection refused")

        # During startup retries, no metrics should exist
        # (This is implementation detail tested in metrics_utility library)

        # In current code, utility.metrics(port) is called at line 255
        # This happens after startup validation, but startup validation
        # may exit before this point if server unavailable


class TestServerUnavailableDuringRuntime(unittest.TestCase):
    """Test exporter behavior when Alpaca server becomes unavailable during runtime"""

    @patch("requests.get")
    def test_runtime_server_failure_marks_devices_disconnected(self, mock_get):
        """
        Test that all devices marked disconnected when server becomes unavailable.

        Scenario:
        1. Exporter running with connected devices
        2. Alpaca server becomes unreachable
        3. All devices should transition to disconnected
        4. Exporter should continue running (not exit)

        Expected:
        - All devices: alpaca_device_connected=0
        - Error counters increment for all devices
        - Exporter keeps running and retrying

        From requirements:
        "Runtime: If server disappears, mark all devices disconnected but keep running"
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Initial state: devices connected
        mock_response_success = Mock()
        mock_response_success.status_code = 200
        mock_response_success.text = json.dumps({"Value": "TestDevice", "ErrorNumber": 0, "ErrorMessage": ""})
        mock_get.return_value = mock_response_success

        # Query telescope
        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertEqual(name, "TestDevice", "Device initially connected")

        # Query camera
        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="camera",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertEqual(name, "TestDevice", "Device initially connected")

        # Server becomes unavailable
        mock_get.side_effect = Exception("Connection refused")

        # Query telescope again - should fail
        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertIsNone(name, "Telescope should now be disconnected")

        # Query camera again - should fail
        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="camera",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertIsNone(name, "Camera should now be disconnected")

        # Error counters should have been incremented
        # (This is verified by the fact that record_metrics=True was passed and None was returned)

    @patch("requests.get")
    def test_runtime_server_recovery_reconnects_devices(self, mock_get):
        """
        Test that devices reconnect when server becomes available again.

        Scenario:
        1. Devices connected
        2. Server fails (devices disconnected)
        3. Server recovers
        4. Devices should reconnect

        Expected:
        - Devices transition back to connected
        - Success counters resume incrementing
        - Normal operation resumes
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Initial: device connected
        mock_response_success = Mock()
        mock_response_success.status_code = 200
        mock_response_success.text = json.dumps({"Value": "TestDevice", "ErrorNumber": 0, "ErrorMessage": ""})
        mock_get.return_value = mock_response_success

        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertEqual(name, "TestDevice")

        # Server fails
        mock_get.side_effect = Exception("Connection refused")

        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertIsNone(name)

        # Server recovers
        mock_get.side_effect = None
        mock_get.return_value = mock_response_success

        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertEqual(name, "TestDevice", "Device should reconnect after server recovery")

    @patch("requests.get")
    def test_discovery_api_failure_during_runtime(self, mock_get):
        """
        Test discovery mode behavior when Management API fails during runtime.

        Scenario:
        1. Discovery mode running normally
        2. Management API becomes unavailable
        3. Should handle gracefully (use last known device list)
        4. Should continue monitoring known devices

        Expected:
        - Discovery returns empty dict or last known devices
        - Doesn't crash or exit
        - Continues monitoring existing devices
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Initial discovery succeeds
        mock_response_success = Mock()
        mock_response_success.status_code = 200
        mock_response_success.text = json.dumps(
            {"Value": [{"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "Test", "UniqueID": "test-001"}], "ErrorNumber": 0, "ErrorMessage": ""}
        )
        mock_get.return_value = mock_response_success

        discovered = alpaca_exporter.discoverDevices(alpaca_base_url="http://localhost:11111/api/v1", verbose=False)
        self.assertEqual(len(discovered), 1)

        # Management API fails
        mock_get.side_effect = Exception("Connection refused")

        discovered = alpaca_exporter.discoverDevices(alpaca_base_url="http://localhost:11111/api/v1", verbose=False)

        # Should return empty dict (handled gracefully in discoverDevices)
        # Main loop should continue with last known devices from all_known_devices
        self.assertEqual(len(discovered), 0, "Failed discovery should return empty dict")


class TestPartialServerFailures(unittest.TestCase):
    """Test behavior with partial server failures (some endpoints work, others don't)"""

    @patch("requests.get")
    def test_management_api_works_device_api_fails(self, mock_get):
        """
        Test when Management API works but Device API fails.

        Scenario:
        - Discovery returns devices successfully
        - Device queries fail (devices appear disconnected)

        Expected:
        - Discovery succeeds
        - All devices marked as disconnected
        - Error counters incremented
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        def selective_failure(url, *_args, **_kwargs):
            if "management" in url:
                # Management API works
                mock_response = Mock()
                mock_response.status_code = 200
                mock_response.text = json.dumps(
                    {"Value": [{"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "Test", "UniqueID": "test-001"}], "ErrorNumber": 0, "ErrorMessage": ""}
                )
                return mock_response
            # Device API fails
            msg = "Connection refused"
            raise ConnectionRefusedError(msg)

        mock_get.side_effect = selective_failure

        # Discovery should work
        discovered = alpaca_exporter.discoverDevices(alpaca_base_url="http://localhost:11111/api/v1", verbose=False)
        self.assertEqual(len(discovered), 1, "Discovery should succeed")

        # Device queries should fail
        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )
        self.assertIsNone(name, "Device query should fail")

    @patch("requests.get")
    def test_http_500_error_treated_as_failure(self, mock_get):
        """
        Test that HTTP 500 errors are treated as device unavailable.

        Server may be up but returning errors - should treat as disconnected.
        """
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Simulate HTTP 500 error
        mock_response = Mock()
        mock_response.status_code = 500
        mock_response.text = "Internal Server Error"
        mock_get.return_value = mock_response

        name = alpaca_exporter.getValue(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )

        # HTTP error should be treated as device unavailable
        self.assertIsNone(name, "HTTP 500 should be treated as device unavailable")


if __name__ == "__main__":
    unittest.main()
