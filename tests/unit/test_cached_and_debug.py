# Generated By: Cursor (Claude Sonnet 4.5)
"""
Unit tests for cached getValue and debug functions

Tests verify caching behavior and debug logging functionality.
"""

import json
import sys
import unittest
from io import StringIO
from pathlib import Path
from unittest.mock import Mock, patch

# Add src directory to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))


class TestGetValueCached(unittest.TestCase):
    """Test the cached version of getValue"""

    @patch("requests.get")
    def test_get_value_cached_makes_request_on_first_call(self, mock_get):
        """Test that first call to cached getValue makes HTTP request"""
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock successful response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.text = json.dumps({"Value": "TestDevice", "ErrorNumber": 0, "ErrorMessage": ""})
        mock_get.return_value = mock_response

        # First call - should hit the network
        value1 = alpaca_exporter.getValueCached(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )

        self.assertEqual(value1, "TestDevice")
        self.assertEqual(mock_get.call_count, 1, "First call should make HTTP request")

    @patch("requests.get")
    def test_get_value_cached_uses_cache_on_second_call(self, mock_get):
        """Test that second call within TTL uses cache"""
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Clear the cache
        if hasattr(alpaca_exporter.getValueCached, "cache_clear"):
            alpaca_exporter.getValueCached.cache_clear()

        # Mock successful response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.text = json.dumps({"Value": "TestDevice", "ErrorNumber": 0, "ErrorMessage": ""})
        mock_get.return_value = mock_response

        # First call
        value1 = alpaca_exporter.getValueCached(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )

        # Second call with same parameters - should use cache
        value2 = alpaca_exporter.getValueCached(
            alpaca_base_url="http://localhost:11111/api/v1",
            device_type="telescope",
            device_number=0,
            attribute="name",
            querystr="",
            record_metrics=True,
        )

        self.assertEqual(value1, "TestDevice")
        self.assertEqual(value2, "TestDevice")
        # Should only make one HTTP request (second call uses cache)
        self.assertEqual(mock_get.call_count, 1, "Second call should use cache, not make another request")


class TestDebugFunction(unittest.TestCase):
    """Test the debug() logging function"""

    def test_debug_prints_when_enabled(self):
        """Test that debug() prints messages when DEBUG is True"""
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Enable debug mode
        alpaca_exporter.DEBUG = True

        # Capture stdout
        captured_output = StringIO()

        with patch("sys.stdout", new=captured_output):
            alpaca_exporter.debug("Test debug message")

        output = captured_output.getvalue()
        self.assertIn("Test debug message", output, "Debug message should be printed when DEBUG=True")

        # Reset DEBUG
        alpaca_exporter.DEBUG = False

    def test_debug_silent_when_disabled(self):
        """Test that debug() doesn't print when DEBUG is False"""
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Disable debug mode
        alpaca_exporter.DEBUG = False

        # Capture stdout
        captured_output = StringIO()

        with patch("sys.stdout", new=captured_output):
            alpaca_exporter.debug("Test debug message")

        output = captured_output.getvalue()
        self.assertEqual(output, "", "Debug message should NOT be printed when DEBUG=False")


class TestDiscoverDevicesSkippedMessage(unittest.TestCase):
    """Test that discoverDevices logs SKIPPED for unsupported device types"""

    @patch("requests.get")
    @patch("builtins.print")
    def test_discover_skips_unsupported_device_with_verbose(self, mock_print, mock_get):
        """Test that unsupported devices log SKIPPED message in verbose mode"""
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API response with unsupported device type
        mock_response = Mock()
        mock_response.status_code = 200
        devices_data = {
            "Value": [
                {"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "Test", "UniqueID": "tel-001"},
                {
                    "DeviceType": "UnsupportedDevice",
                    "DeviceNumber": 0,
                    "DeviceName": "Unknown",
                    "UniqueID": "unk-001",
                },
            ],
            "ErrorNumber": 0,
            "ErrorMessage": "",
        }
        mock_response.text = json.dumps(devices_data)
        mock_get.return_value = mock_response

        # Call with verbose=True
        discovered = alpaca_exporter.discoverDevices(alpaca_base_url="http://localhost:11111/api/v1", verbose=True)

        # Check that SKIPPED message was printed
        print_calls = [str(call) for call in mock_print.call_args_list]
        skipped_found = any("SKIPPED" in str(call) and "unsupporteddevice" in str(call) for call in print_calls)

        self.assertTrue(skipped_found, "Should log SKIPPED message for unsupported device type in verbose mode")

    @patch("requests.get")
    @patch("builtins.print")
    def test_discover_silent_skip_without_verbose(self, mock_print, mock_get):
        """Test that unsupported devices are silently skipped when verbose=False"""
        from importlib import import_module

        alpaca_exporter = import_module("alpaca-exporter")

        # Mock Management API response with unsupported device type
        mock_response = Mock()
        mock_response.status_code = 200
        devices_data = {
            "Value": [
                {"DeviceType": "Telescope", "DeviceNumber": 0, "DeviceName": "Test", "UniqueID": "tel-001"},
                {
                    "DeviceType": "UnsupportedDevice",
                    "DeviceNumber": 0,
                    "DeviceName": "Unknown",
                    "UniqueID": "unk-001",
                },
            ],
            "ErrorNumber": 0,
            "ErrorMessage": "",
        }
        mock_response.text = json.dumps(devices_data)
        mock_get.return_value = mock_response

        # Reset mock
        mock_print.reset_mock()

        # Call with verbose=False
        discovered = alpaca_exporter.discoverDevices(alpaca_base_url="http://localhost:11111/api/v1", verbose=False)

        # Check that SKIPPED message was NOT printed
        print_calls = [str(call) for call in mock_print.call_args_list]
        skipped_found = any("SKIPPED" in str(call) for call in print_calls)

        self.assertFalse(skipped_found, "Should NOT log SKIPPED message when verbose=False")

        # Verify unsupported device not in results
        self.assertNotIn("unsupporteddevice", discovered, "Unsupported device should be filtered out")


if __name__ == "__main__":
    unittest.main()
