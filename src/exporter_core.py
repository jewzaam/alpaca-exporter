# Generated By: Cursor (Claude Sonnet 4.5)
"""
Core exporter logic extracted for testability.

This module contains the main execution logic that was previously in the
if __name__ == "__main__" block, now refactored into testable functions.
"""

import copy

import constants
import utility


def parse_config_defaults(args):
    """
    Extract configuration values from args with defaults.

    Args:
        args: Dictionary of parsed command line arguments

    Returns:
        tuple: (alpaca_base_url, refresh_rate, port)
    """
    alpaca_base_url = constants.DEFAULT_ALPACA_BASE_URL
    if args.get("alpaca_base_url"):
        alpaca_base_url = args["alpaca_base_url"].rstrip("/")

    refresh_rate = constants.DEFAULT_REFRESH_RATE
    if args.get("refresh_rate"):
        refresh_rate = args["refresh_rate"]

    port = constants.DEFAULT_PORT
    if args.get("port"):
        port = args["port"]

    return alpaca_base_url, refresh_rate, port


def is_discover_mode(args):
    """
    Check if running in discovery mode and validate configuration.

    Args:
        args: Dictionary of parsed command line arguments

    Returns:
        bool: True if using discovery mode, False if using manual mode

    Raises:
        ValueError: If both modes specified or neither mode specified
    """
    use_discovery = args.get("discover")
    has_explicit_devices = any(args.get(dt) for dt in constants.DEVICE_TYPES)

    # Validate mutually exclusive modes
    if use_discovery and has_explicit_devices:
        msg = "Cannot use --discover with explicit device specifications. Usage: Either use '--discover' OR specify devices (e.g., '--telescope 0 --camera 0')"
        raise ValueError(msg)

    if not use_discovery and not has_explicit_devices:
        msg = "Must specify either --discover or at least one device. Usage: '--discover' OR explicit devices (e.g., '--telescope 0 --camera 0')"
        raise ValueError(msg)

    return use_discovery


def get_manual_device_list(args):
    """
    Build device list from command line arguments in manual mode.

    Args:
        args: Dictionary of parsed command line arguments

    Returns:
        dict: Devices dictionary {device_type: [device_numbers]}
    """
    devices = {}
    for device_type in constants.DEVICE_TYPES:
        if args.get(device_type):
            devices[device_type] = args[device_type]
    return devices


def create_device_labels(labels, name, alpaca_base_url, device_type, device_number, label_configs, querystr, get_value_fn, get_value_cached_fn):
    """
    Create labels for a device from configuration.

    Args:
        labels: Base labels dict to update
        name: Device name
        alpaca_base_url: Base URL for Alpaca API
        device_type: Type of device
        device_number: Device number
        label_configs: List of label configurations
        querystr: Query string for device (e.g. "id=0" for switches)
        get_value_fn: Function to get device values
        get_value_cached_fn: Function to get cached device values
    """
    for l in label_configs:
        alpaca_name = l["alpaca_name"]
        label_name = alpaca_name
        if "label_name" in l:
            label_name = l["label_name"]

        if alpaca_name == "name":
            # already pulled this early on
            label_value = name
        elif "cached" in l and l["cached"] > 0:
            label_value = get_value_cached_fn(alpaca_base_url, device_type, device_number, alpaca_name, querystr)
        else:
            label_value = get_value_fn(alpaca_base_url, device_type, device_number, alpaca_name, querystr)

        if label_name and label_value:
            labels[label_name] = label_value


def collect_device_metrics(labels, configurations, device_type, metric_prefix, alpaca_base_url, device_number, querystr, get_value_fn, get_value_cached_fn):
    """
    Collect metrics for a device from configuration.

    Args:
        labels: Labels dict for the device
        configurations: All device configurations
        device_type: Type of device
        metric_prefix: Prefix for metric names
        alpaca_base_url: Base URL for Alpaca API
        device_number: Device number
        querystr: Query string for device
        get_value_fn: Function to get device values
        get_value_cached_fn: Function to get cached device values

    Returns:
        list: List of [metric_name, labels] tuples collected
    """
    metrics_collected = []
    c = configurations[device_type]

    for m in c["metrics"]:
        alpaca_name = m["alpaca_name"]
        if "metric_name" not in m:
            metric_name = f"{metric_prefix}{alpaca_name}"
        else:
            metric_name = f"{metric_prefix}{m['metric_name']}"

        if "cached" in m and m["cached"] > 0:
            metric_value = get_value_cached_fn(alpaca_base_url, device_type, device_number, alpaca_name, querystr)
        else:
            metric_value = get_value_fn(alpaca_base_url, device_type, device_number, alpaca_name, querystr)

        # if metric_value is None we'll try to clear it
        # if it's none but there is no prior value it will fail, ignore this
        try:
            utility.set(metric_name, metric_value, labels)
            metrics_collected.append([metric_name, copy.deepcopy(labels)])
        except:
            pass

    return metrics_collected


def process_device(
    device_type,
    device_number,
    configurations,
    alpaca_base_url,
    use_discovery,
    devices,
    device_status,
    skip_device_attribute,
    get_value_fn,
    get_value_cached_fn,
):
    """
    Process a single device - check connectivity and collect metrics.

    Args:
        device_type: Type of device
        device_number: Device number
        configurations: All device configurations
        alpaca_base_url: Base URL for Alpaca API
        use_discovery: Boolean indicating if in discovery mode
        devices: Current discovered devices dict
        device_status: Device status tracking dict
        skip_device_attribute: Skip list tracking dict
        get_value_fn: Function to get device values
        get_value_cached_fn: Function to get cached device values

    Returns:
        list: List of [metric_name, labels] tuples collected for this device
    """
    metrics_current = []
    c = configurations[device_type]

    if "metrics" not in c:
        # no metrics, no point processing anything
        return metrics_current

    # collect labels for device this iteration
    labels = {
        "device_type": device_type,
        "device_number": device_number,
    }

    # Track device status for state change detection
    device_key = f"{device_type}/{device_number}"
    was_connected = device_status.get(device_key)

    # Check if device is in currently discovered devices (for discovery mode)
    is_currently_discovered = True
    if use_discovery:
        is_currently_discovered = device_type in devices and device_number in devices[device_type]

    # If not discovered, mark as disconnected (only if previously connected)
    if not is_currently_discovered:
        if was_connected is True:
            print(f"DISCONNECTED: {device_type}/{device_number} no longer discovered")
            utility.set("alpaca_device_connected", 0, labels)
            metrics_current.append(["alpaca_device_connected", copy.deepcopy(labels)])
        device_status[device_key] = False
        return metrics_current

    # Verify this is a valid device by getting its name
    # Only record metrics if device has been connected before
    should_record = was_connected is True
    name = get_value_fn(alpaca_base_url, device_type, device_number, "name", "", should_record)

    if not name:
        if was_connected is True:
            print(f"DISCONNECTED: {device_type}/{device_number} not responding")
            utility.set("alpaca_device_connected", 0, labels)
            metrics_current.append(["alpaca_device_connected", copy.deepcopy(labels)])
        device_status[device_key] = False
        return metrics_current

    # Device is connected - create/update metrics
    # NOTE: 'name' label is not added until after the connected metric is created/updated
    utility.set("alpaca_device_connected", 1, labels)
    metrics_current.append(["alpaca_device_connected", copy.deepcopy(labels)])

    # Print CONNECTED when device becomes available (transitioning from any non-connected state)
    if was_connected is not True:
        print(f"CONNECTED: {device_type}/{device_number}")
        # Reset skip list on connect (new connection may have different driver/capabilities)
        skip_device_attribute.setdefault(device_type, {})[str(device_number)] = []

    device_status[device_key] = True
    labels.update({"name": name})
    utility.set("alpaca_device_name", 1, labels)
    metrics_current.append(["alpaca_device_name", copy.deepcopy(labels)])

    metric_prefix = ""
    if "metric_prefix" in c:
        metric_prefix = c["metric_prefix"]

    # Collect global labels
    if "global" in configurations and "labels" in configurations["global"]:
        create_device_labels(
            labels,
            name,
            alpaca_base_url,
            device_type,
            device_number,
            configurations["global"]["labels"],
            "",
            get_value_fn,
            get_value_cached_fn,
        )

    # SWITCH is a special device with an "id" query param
    if device_type == "switch":
        ids = get_value_cached_fn(alpaca_base_url, device_type, device_number, "maxswitch")
        for id in range(ids):
            # Create a copy of labels for each switch ID
            switch_labels = labels.copy()
            switch_labels["id"] = id
            querystr = f"id={id}"

            # Device specific labels for this switch ID
            if "labels" in c:
                create_device_labels(switch_labels, name, alpaca_base_url, device_type, device_number, c["labels"], querystr, get_value_fn, get_value_cached_fn)

            # Collect metrics for this switch ID
            collected = collect_device_metrics(
                switch_labels, configurations, device_type, metric_prefix, alpaca_base_url, device_number, querystr, get_value_fn, get_value_cached_fn
            )
            metrics_current.extend(collected)
    else:
        # All other devices do not have query params
        # Device specific labels
        if "labels" in c:
            create_device_labels(labels, name, alpaca_base_url, device_type, device_number, c["labels"], "", get_value_fn, get_value_cached_fn)

        # Collect metrics
        collected = collect_device_metrics(labels, configurations, device_type, metric_prefix, alpaca_base_url, device_number, "", get_value_fn, get_value_cached_fn)
        metrics_current.extend(collected)

    return metrics_current


def cleanup_stale_metrics(metrics_previous, metrics_current):
    """
    Remove metrics that were collected in previous cycle but not current.

    Args:
        metrics_previous: List of [metric_name, labels] from previous cycle
        metrics_current: List of [metric_name, labels] from current cycle
    """
    for m in metrics_previous:
        # if the cache has a value we didn't just collect we must remove the metric
        if m not in metrics_current:
            metric_name = m[0]
            labels = m[1]  # type: ignore[assignment]
            # wipe the metric
            utility.set(metric_name, None, labels)
